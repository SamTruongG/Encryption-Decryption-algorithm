# Encryption/Decryption Application
I developed this application using C++ as part of my exploration of object-oriented programming (OOP). Throughout the process, I gained valuable experience with the Google Test framework, building on the skills I acquired last year while utilizing MSTest to create an Excel clone in C#. I also applied my understanding of finite-state machines, which I learned in an automata theory course during my time in Utah, to design the user menu.
While I see opportunities for further improvements, I am excited about the knowledge I gained throughout this project and am overall pleased with the final outcome.

## Compilation Instructions
```g++ -std=c++14 -o encryption-decryption encryption-decryption.cpp menu_printer.hpp```
##  Encoder
•	The Encoder inserts a message into a square grid and encrypts it using a diamond traversal pattern. 

•	It allows for manual or automatic grid size definition. 

•	The encrypted message is generated by concatenating characters column by column from left to right and top to bottom. 

•	It can automatically append a full stop at the end of the message if it isn't present, but only during the first round of encryption. This full stop helps identify the end of a message that does not perfectly center in the grid. 	

•	It supports multi-round encryption by taking the output of one encryption round as input for the next, adjusting the grid size based on the length of the new message.

## Decoder
•	The Decoder reconstructs the original message from an encrypted one by reversing the diamond traversal pattern used in the Encoder. 	

•	It fills a square grid with characters from the encrypted message and reads them in a specific order to recreate the original message. 	

•	For multi-round encryption, the Decoder adjusts the grid size to be the square root of the length of the encrypted message after each round. 	

•	If it’s not the final round and the resulting encrypted message isn’t a perfect square of an odd number, the Decoder will truncate characters from the end of the message until it is.

## Menu
•	The Menu class serves as a user interface for interacting with the Encoder and Decoder. 	

•	It is implemented as a finite state machine (FSM). 	

•	Users can easily choose between encoding and decoding messages, set grid sizes, and view the results of their operations.

UML Diagram

# OOP/C++ Concepts Used
## Basic C++ Coding
•	Utilized vectors for the grid and state transitions. 	

•	Employed ⁠auto in multiple instances to simplify syntax.

•	Overloaded ⁠setGrid() and constructors within the MessageHandler class family. 

•	Implemented range-based for-loops to iterate over strings. 	

•	Used initializer lists in specific constructors. 	

•	Applied reference variables to handle both unencrypted and encrypted message strings.

## Standard Template Library (STL)
•	Containers and Iterators: Utilized vectors for the grid and iterators to count the occurrences of full stops in messages. 	

•	Algorithms: Employed various STL algorithms like ⁠std::count for counting full stops, ⁠std::find for locating full stops, and ⁠std::generate to fill grids with random characters. Additionally, ⁠std::remove_if was used to eliminate whitespaces.
Class Design & OOP Principles

•	Each class is designed with appropriate access specifiers. 	

•	Applied ⁠const for getters/accessors, along with mutators/setters. 	

•	Separated specifications from implementations using header files and .cpp files. 	

•	Defined inline functions in class declarations for simple members. 	

•	Overloaded member functions, including constructors, and utilized constructor delegation. 	

•	Used initializer lists for certain constructors and the ⁠this pointer for accessing transitions.

## Advanced OOP Concepts
•	Inheritance: The Decoder and Encoder classes inherit from the MessageHandler base class. 	

•	Polymorphism: This was illustrated through constructor/function overloading and overriding of virtual functions. MessageHandler is an abstract base class with pure virtual functions implemented by derived classes. 	

•	Implemented helper functions as static to ensure they do not modify or access non-static member variables.

## Exception Handling and Lambda Functions
•	Implemented exception handling for invalid scenarios, primarily using ⁠invalid_argument with custom messages. 	

•	Utilized try/catch blocks in the Menu class to handle exceptions from Encoder and Decoder classes. 	

•	Used an anonymous function for filling the grid with ⁠std::generate.

## Testing
Unit tests were written concurrently with the development of the MessageHandler, Encoder, and Decoder classes using the Google Test framework. After some refactoring, these tests are currently non-functional, but I plan to update this section when they are operational.
The tests, located in the ⁠tests directory, serve to demonstrate my understanding of unit testing and the Google Test framework, though they are not essential for the application’s operation.
